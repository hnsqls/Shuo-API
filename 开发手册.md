# 前端项目初始化

使用React Ant Design Pro [开始使用 - Ant Design Pro](https://pro.ant.design/zh-CN/docs/getting-started)

通过脚手架安装。

安装后，下载依赖，启动项目，可以先以mock启动

没问题，就删除不需要的模块。

1.先删除国际化：没啥用,脚本提供了删除，然后在删除文件， 删除后运行以下看是否出错。

antDesign 脚本写的不好，还有未删除的元素，那就手动删除， `SelectLang`

2.删除测试，删除后运行看是否报错

3.



# 后端项目初始化

使用自己总结的开发模板



# 库表设计

要做一个接口的开放平台，先实现基础的功能，用户的登录注册，以及管理，

```sql
-- 创建库
create database if not exists shuo_api;

-- 切换库
use shuo_api;

-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                           not null comment '账号',
    userPassword varchar(512)                           not null comment '密码',
    unionId      varchar(256)                           null comment '微信开放平台id',
    mpOpenId     varchar(256)                           null comment '公众号openId',
    userName     varchar(256)                           null comment '用户昵称',
    userAvatar   varchar(1024)                          null comment '用户头像',
    userProfile  varchar(512)                           null comment '用户简介',
    userRole     varchar(256) default 'user'            not null comment '用户角色：user/admin/ban',
    editTime     datetime     default CURRENT_TIMESTAMP not null comment '编辑时间',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    index idx_unionId (unionId)
) comment '用户' collate = utf8mb4_unicode_ci;

```

其次就是接口的管理

```sql
-- 接口信息
create table if not exists yuapi.`interface_info`
(
  `id` bigint not null auto_increment comment '主键' primary key,
  `name` varchar(256) not null comment '名称',
  `description` varchar(256) null comment '描述',
  `url` varchar(512) not null comment '接口地址',
  `requestHeader` text null comment '请求头',
  `responseHeader` text null comment '响应头',
  `status` int default 0 not null comment '接口状态（0-关闭，1-开启）',
  `method` varchar(256) not null comment '请求类型',
  `userId` bigint not null comment '创建人',
  `createTime` datetime default CURRENT_TIMESTAMP not null comment '创建时间',
  `updateTime` datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
  `isDelete` tinyint default 0 not null comment '是否删除(0-未删, 1-已删)'
) comment '接口信息';

```



# 实现接口信息的增删改查

没啥

# 配置openapi

后端接口文档的json地址

如图

![image-20250409221609359](images/开发手册.assets/image-20250409221609359.png)

配置前端请求后端的地址

![image-20250409222436663](images/开发手册.assets/image-20250409222436663.png)

自动的生成接口调用

![image-20250409222513459](images/开发手册.assets/image-20250409222513459.png)



# 登录注册实现

现有的登录，请求的 是假的接口，所以我们修改登录页面的请求逻辑，让其请求我们后端自己的接口，同时要表单参数和请求参名称的对应。

主要：修改请求的axios,当然记得修改请求参数。

![image-20250409225031664](images/开发手册.assets/image-20250409225031664.png)

![image-20250409225003804](images/开发手册.assets/image-20250409225003804.png)

现在点击登录后，登录完成，并没有跳转

分析：有跳转逻辑没，代码中是有的。

![image-20250409225146965](images/开发手册.assets/image-20250409225146965.png)

控制台发现

![image-20250409225246351](images/开发手册.assets/image-20250409225246351.png)

改为请求我们自己的获取当前登录用户，更改请求地址，更改请求参数。没问题

没问题了，为什么还是跳转不了，原因是没有携带session，在全局的请求配置中允许携带session

```ts
 baseURL:'http://localhost:8848',
  withCredentials: true,
```

登录后头像不显示，一直转圈，就看头像组件的信息，参数不对。



fixbug: 管理页面不显示，

首先找到前端的管理认证的逻辑

![image-20250409233538528](images/开发手册.assets/image-20250409233538528.png)

# 接口列表的增删改查页面

实现页面的展示，以及请求后端对应的api.

修改colume字段的信息，修改请求

修改接口也没问题。

现在删除，新增还有点小问题。

删除问题：单个删除（新增），批量删除（未实现）

新增接口：修复字段

# 开发接口调用

调用的几种方式



* ### 1. **OkHttp**

  **定位**：轻量级HTTP客户端
  **特点**：

  + 基于HTTP/2和连接池的高性能实现
  + 支持同步/异步调用
  + 灵活的拦截器机制
  + 需要手动处理JSON序列化

  **示例代码**：

  

  ```java
  // 同步GET请求
  OkHttpClient client = new OkHttpClient();
  Request request = new Request.Builder()
      .url("https://api.example.com/data")
      .build();
  Response response = client.newCall(request).execute();
  String responseData = response.body().string();
  
  // 异步请求
  client.newCall(request).enqueue(new Callback() {
      @Override
      public void onResponse(Call call, Response response) {
          // 处理响应
      }
  });
  ```

  ------

  ### 2. **RestTemplate (Spring)**

  **定位**：Spring传统REST客户端
  **特点**：

  + 同步阻塞式调用
  + 集成Spring生态（如自动序列化）
  + 即将被弃用（推荐WebClient替代）

  **示例代码**：

  ```java
  RestTemplate restTemplate = new RestTemplate();
  String result = restTemplate.getForObject(
      "https://api.example.com/users/{id}", 
      String.class, 
      "123");
  ```

  ------

  ### 3. **OpenFeign (Spring Cloud)**

  **定位**：声明式HTTP客户端
  **特点**：

  + 通过接口注解定义API
  + 集成Ribbon负载均衡
  + 支持熔断（配合Hystrix/Sentinel）
  + 自动序列化/反序列化

  **示例代码**：

  

  ```java
  @FeignClient(name = "user-service")
  public interface UserService {
      @GetMapping("/users/{id}")
      User getUser(@PathVariable("id") String id);
  }
  
  // 自动生成实现类
  UserService service = Feign.builder()
      .target(UserService.class, "https://api.example.com");
  ```

  ------

  ### 4. **Hutool HttpUtil**

  **定位**：国产工具类HTTP封装
  **特点**：

  + 超简化的API设计
  + 适合快速开发和小项目
  + 功能相对基础

  **示例代码**：

  

  ```java
  // GET请求
  String result = HttpUtil.get("https://api.example.com/data");
  
  // POST表单
  HashMap<String, Object> paramMap = new HashMap<>();
  paramMap.put("key", "value");
  String result = HttpUtil.post("https://api.example.com/submit", paramMap);
  ```

  ------

  ### 5. **WebClient (Spring 5+)**

  **定位**：响应式HTTP客户端
  **特点**：

  + 非阻塞IO（基于Netty）
  + 函数式API风格
  + 支持SSE/WebSocket
  + Spring官方推荐替代RestTemplate

  **示例代码**：

  ```java
  WebClient client = WebClient.create();
  Mono<String> result = client.get()
      .uri("https://api.example.com/data")
      .retrieve()
      .bodyToMono(String.class);
  
  // 阻塞获取结果（非响应式场景）
  String response = result.block();
  ```

  ------

  ### 对比总结

  | 工具             | 同步/异步 | 学习成本 | 适用场景                  | 性能   | 扩展性       |
  | :--------------- | :-------- | :------- | :------------------------ | :----- | :----------- |
  | **OkHttp**       | 都支持    | 中       | 移动端/需要精细控制的场景 | 非常高 | 高（拦截器） |
  | **RestTemplate** | 同步      | 低       | 传统Spring应用            | 一般   | 中           |
  | **OpenFeign**    | 同步      | 中       | 微服务间调用              | 高     | 高           |
  | **Hutool**       | 同步      | 极低     | 简单HTTP请求              | 一般   | 低           |
  | **WebClient**    | 异步      | 高       | 响应式编程/高并发场景     | 非常高 | 高           |

  ------

  ### 选型建议：

  1. **微服务开发**：优先选择 `OpenFeign` + 负载均衡
  2. **高性能需求**：`OkHttp` 或 `WebClient`
  3. **快速原型开发**：`Hutool HttpUtil`
  4. **响应式编程**：必须使用 `WebClient`
  5. **旧系统维护**：暂时保留 `RestTemplate`（逐步迁移）



那就使用Hutool吧：[Http客户端工具类-HttpUtil](https://www.hutool.cn/docs/#/http/Http客户端工具类-HttpUtil)

快速开发，简单的模拟几个接口调用

例如: GET POST  请求

参数 路径 url  json

```java
@RestController
@RequestMapping("/user")
public class UserController {

    @GetMapping("/name/{name}")
    public String getUserByGet(@PathVariable String name){
        return "GET:hello " + name;
    }

    @PostMapping("/name")
    public String getUserByPost(@RequestParam String name){
        return "POST:hello " + name;
    }

    @PostMapping("/json")
    public String getUserByJson(@RequestBody User user) {
        return "POST Json :hello " + user.getName();
    }
}
```

使用hutool HttpUtil  [Http客户端工具类-HttpUtil](https://www.hutool.cn/docs/#/http/Http客户端工具类-HttpUtil)

```java
/**
 * 调用接口的客户端
 */
@Component
public class ShuoApiClient {

    public String getUserByGet(String name){
        return HttpUtil.get("http://localhost:8849/api/user/name/" + name);
    }

    public String getUserByPost(String name){
        HashMap<String, Object> paramMap = new HashMap<>();
        paramMap.put("name", name);
        return HttpUtil.post("http://localhost:8849/api/user/name", paramMap);
    }

    public String getUserByJson(User user) {
        String json = JSONUtil.toJsonStr(user);
        HttpResponse execute = HttpRequest.post("http://localhost:8849/api/user/json")
                .body(json)
                .execute();
        return execute.body();
    }
}

```

# 签名认证开发

我们提供了接口调用，但是现在不知道有谁调用了。

不能随便调用，所以要认证

可以设计一个签名认证，我们给用户发送签名，用户调用接口需要携带该签名，根据该签名认证用户。

设计

* accessKey 
* secretKey

为啥不直接用登录的校验呢？登录的用户能调用不就行了，为什么还要设计accessKey以及secretKey.

要清楚，我们的API调用是提供给其他程序的，不是在本平台，也就是所以不能用登录认证，而是设计一个类似登录账号，密码的认证方式，允许调用API。

如何设计?

大概的思路

服务端：发放accessKey，以及secretKey。在调用的请求头，加上ack以及sck，进行认证。

调用的客户端修改-新增accessKey，secretKey 生成。 同时在发送请求时在请求头中携带accessKey,secretKey。

```java
/**
 * 调用接口的客户端
 */
public class ShuoApiClient {
    private String accessKey;
    private String secretKey;

    /**
     * 添加请求头信息
     *
     * @return
     */
    private HashMap<String, String> getHeaderMap() {
        HashMap<String, String> headers = new HashMap<>();
        headers.put("accessKey", accessKey);
        headers.put("secretKey", secretKey);
        return headers;
    }

    // 添加构造方法
    public ShuoApiClient(String accessKey, String secretKey) {
        this.accessKey = accessKey;
        this.secretKey = secretKey;
    }

    public String getUserByGet(String name) {
        return HttpRequest.get("http://localhost:8849/api/user/name/" + name)
                .addHeaders(getHeaderMap())
                .execute()
                .body();
    }

    public String getUserByPost(String name) {
        HashMap<String, Object> paramMap = new HashMap<>();
        paramMap.put("name", name);
        return HttpRequest.post("http://localhost:8849/api/user/name")
                .addHeaders(getHeaderMap())
                .form(paramMap)
                .execute()
                .body();
    }

    public String getUserByJson(User user) {
        String json = JSONUtil.toJsonStr(user);
        return HttpRequest.post("http://localhost:8849/api/user/json")
                .addHeaders(getHeaderMap())
                .body(json)
                .execute()
                .body();
    }
}
```

服务端，根据请求头中的数据进行校验,

主要就是从请求头中取出数据，进行校验，

```java
@RestController
@RequestMapping("/user")
public class UserController {

    @GetMapping("/name/{name}")
    public String getUserByGet(@PathVariable String name, HttpServletRequest request){
        String accessKey = request.getHeader("accessKey");
        String secretKey = request.getHeader("secretKey");
        if (!Objects.equals(accessKey, "hnsqls") || !Objects.equals(secretKey, "hnsqls")) {
            return "accessKey or secretKey is wrong";
        }

        return "GET:hello " + name;
    }

    @PostMapping("/name")
    public String getUserByPost(@RequestParam String name,HttpServletRequest request){
        String accessKey = request.getHeader("accessKey");
        String secretKey = request.getHeader("secretKey");
        if (!Objects.equals(accessKey, "hnsqls") || !Objects.equals(secretKey, "hnsqls")) {
            return "accessKey or secretKey is wrong";
        }
        return "POST:hello " + name;
    }

    @PostMapping("/json")
    public String getUserByJson(@RequestBody User user,HttpServletRequest request) {
        String accessKey = request.getHeader("accessKey");
        String secretKey = request.getHeader("secretKey");
        if (!Objects.equals(accessKey, "hnsqls") || !Objects.equals(secretKey, "hnsqls")) {
            return "accessKey or secretKey is wrong";
        }
        return "POST Json :hello " + user.getName();
    }
}

```

tips： 可以在写一个拦截器，或者AOP切面，进行校验。

